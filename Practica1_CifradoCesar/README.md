En esta práctica Realizamos un código para implementar el cifrado cesar un método que desplaza cada letra del mensaje un número fijo de posiciones en el alfabeto, definido por una llave. Para encriptar, se recorre el texto carácter por carácter, ignorando los espacios, y si el carácter es letra mayúscula o minúscula, se ajusta su valor ASCII para aplicar el desplazamiento circular dentro del rango de letras. La función de desencriptado realiza el proceso inverso, restando la llave para recuperar el texto original.

Para implementarlo se planteo primero utilizar un arreglo dinámico con apuntadores (char* con malloc) para almacenar el mensaje, lo que permite manejar cadenas de longitud variable sin depender de un arreglo estático. Al final, se libera la memoria con free para evitar fugas.

Las funciones encriptado y descencriptado trabajan recorriendo el arreglo de caracteres índice por índice con un ciclo for. En encriptado, cada letra se convierte a un índice de 0–25 restando su código ASCII base ('A' o 'a'), se suma la llave, según se encriptado y  la llave y se aplica modulo de 26 para mantener el rango de letras, volviendo luego a ASCII. En descencriptado el procedimiento es el mismo, pero restando la llave para deshacer el desplazamiento. El programa principal (main) solicita el mensaje y la llave, presenta un menú para elegir acción y, según la opción, llama a la función adecuada, mostrando el resultado hasta que el usuario decida salir.

La implementación elegida para realizar el cifrado César se basó en su simplicidad y eficiencia, ya que permite transformar el mensaje directamente sobre el mismo arreglo de caracteres sin necesidad de estructuras adicionales, optimizando el uso de memoria. El uso de operaciones aritméticas sobre los valores ASCII facilita el manejo diferenciado entre mayúsculas y minúsculas, manteniendo la compatibilidad con el alfabeto estándar. Además, la aplicación del operador módulo garantiza el comportamiento circular del cifrado, lo que hace que el desplazamiento sea predecible y reversible, condición necesaria para que el descifrado recupere exactamente el mensaje original. Esta solución es directa, clara y suficiente para demostrar el principio del algoritmo sin introducir complejidad innecesaria.
